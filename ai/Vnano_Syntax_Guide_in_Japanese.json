{
	"page0": {
		"title": "Vnano 公式サイト",
		"description": "Vnanoの公式サイトのトップページです。Vnanoの概要を紹介しています。",
		"text": "# Vnano 公式サイト\n\nようこそ。ここはスクリプトエンジン\/言語「 Vnano 」の公式サイトです。\n\n\n## Vnanoとは？\n\n### Java&trade;製アプリ内に組み込める、コンパクトなスクリプトエンジン\/言語\n\nVnano（VCSSL nano）は、小型で高速なスクリプトエンジン、およびその上で動作するスクリプト言語です。Java製のソフトウェア内に簡単に組み込めるため、アプリ内スクリプト機能の実装に利用できます。\n\n&raquo; [Vnanoを用いたアプリケーション例： RINPn (関数電卓)](https:\/\/www.rinearn.com\/ja-jp\/rinpn\/)\n\n### 普通のスクリプト言語として使う事も可能で、特に演算処理が高速\n\n[VCSSLランタイム](https:\/\/www.vcssl.org\/ja-jp\/download\/) という実行環境を用いて、普通のスクリプト言語として使う事もできます。 アプリ内組み込みを重視した言語なため、機能は限定的ですが、演算処理が速いため、計算用途などに便利かもしれません。\n\n&raquo; [例： 積分値を計算するスクリプト](https:\/\/www.vcssl.org\/ja-jp\/code\/archive\/0001\/7800-vnano-integral-output\/)\n\n### C言語風のオーソドックスな文法\n\n文法面から見たVnanoは、アプリケーション上でのちょっとしたスクリプト処理に焦点を合わせた、シンプルな簡易言語です。 オーソドックスなC言語風のコードで、C系言語ユーザーが \"雰囲気で\" 読み書きできます。\n\n\\- スクリプト記述例 -\n\n    int sum = 0;\n    for (int i=1; i<=100; i++) {\n        sum += i;\n    }\n    output(sum);\n\n&raquo; [詳しく: Vnano の言語の主な文法・仕様](https:\/\/www.vcssl.org\/ja-jp\/vnano\/doc\/tutorial\/language)\n\n### オープンソース、MITライセンス\n\nVnanoのスクリプトエンジンはオープンソースで、ユーザーはMITライセンスに基づき、商用・非商用問わず無償で利用できます。 また、アプリケーションに合わせて改造したり、派生版を作って公開する事も可能です。\n\n&raquo; [ソースコードリポジトリ](https:\/\/github.com\/RINEARN\/vnano)\n\n\n## 導入はすぐ完了！ いまここで試してみよう\n\nVnanoを使い始めるのはとても簡単で、恐らく数分で試せます。実際にここで試してみましょう！\n\n### Step1. Vnanoのスクリプトエンジンをダウンロード\n\nまずは、以下からVnanoのビルド済みパッケージをダウンロード・展開します。 展開されたフォルダ内に、Vnano のスクリプトエンジンである「 Vnano.jar 」が入っています。\n\n[公式サイトのトップページ、ビルド済み版のダウンロードリンクあり](https:\/\/www.vcssl.org\/ja-jp\/vnano\/)\n\n    ※ ご使用前に、MITライセンスの免責事項にご同意ください。 &raquo; [ライセンス文書](https:\/\/github.com\/RINEARN\/vnano\/blob\/master\/LICENSE)\n\n    ※ 本格的な利用では、アプリ開発に使うバージョンのJDKで、エンジンもソースコードからビルドするのが無難です。 &raquo; [方法](https:\/\/www.vcssl.org\/ja-jp\/vnano\/doc\/tutorial\/use)\n\nなお、スクリプトエンジンを自作アプリ内に組み込んだりせずに、単にVnanoのスクリプトを（他のスクリプト言語のように）実行して使うだけの場合は、代わりに [VCSSLランタイム](https:\/\/www.vcssl.org\/ja-jp\/download\/) を導入してください。\n\n### Step-2. スクリプトファイルを実行してみる\n\n展開フォルダ内には、Vnano で記述されたスクリプトファイルが同梱されています：\n\n\\- ExampleScript1.vnano -\n\n    int sum = 0;\n    for (int i=1; i<=100; i++) {\n        sum += i;\n    }\n    output(sum);\n\nこれは、1から100までの和を計算する内容になっています。 展開フォルダ内にコマンドライン端末で cd し、以下のように実行できます：\n\n    java -jar Vnano.jar ExampleScript1.vnano\n\n    ※ Java開発環境（JDK）が必要です。\n\nなお、[VCSSLランタイム](https:\/\/www.vcssl.org\/ja-jp\/download\/) を導入したPC上では、ランタイムを起動して上記スクリプトを選択するだけで、簡単に実行できます （パス設定をすればコマンドでの実行も可能です）。\n\n実行すると以下のように、計算結果が出力されます：\n\n    5050\n\n\n### Step3. Javaアプリケーションから呼び出してみる\n\n展開フォルダ内には、Vnano のスクリプトエンジンを、 Javaアプリケーションから呼び出して使うサンプルコード類も同梱されています：\n\n\\- ExampleApp1.java -\n\n    import org.vcssl.nano.VnanoEngine;\n    import org.vcssl.nano.VnanoException;\n\n    public class ExampleApp1 {\n        public static void main(String[] args) throws VnanoException {\n\n            \/\/ Vnano のスクリプト実行エンジン（Vnano Engine）のインスタンスを生成\n            VnanoEngine engine = new VnanoEngine();\n\n            \/\/ 単純な内容のスクリプトを用意し、Vnano Engine で実行\n            String script = \"double a = 1.2;  double b = 3.4;  double c = a + b;  c;\";\n            double result = (Double)engine.executeScript(script);\n\n            \/\/ 結果を表示\n            System.out.println(\"result: \" + result);\n        }\n    }\n\nこれは、「 1.2 + 3.4 」を計算する簡単なスクリプトを処理する内容になっています。 展開フォルダ内にコマンドライン端末で cd し、以下のようにコンパイルして実行できます：\n\n    (Windows の場合)\n    javac -cp .;Vnano.jar ExampleApp1.java\n    java -cp \".;Vnano.jar\" ExampleApp1\n\n    (Linux 等での場合)\n    javac -cp .:Vnano.jar ExampleApp1.java\n    java -cp \".:Vnano.jar\" ExampleApp1\n\n    ※ Java開発環境（JDK）が必要です。\n\n実行結果は：\n\n    result: 4.6\n\nこの通り、Vnano のスクリプトエンジンは簡単に導入\/使用できます。本格的な使い方は以下をご参照ください：\n\n&raquo; 詳しく: [Vnano チュートリアル ガイド](https:\/\/www.vcssl.org\/ja-jp\/vnano\/doc\/tutorial\/)\n\n\n## Vnano公式サイト コンテンツ一覧\n\nこのVnano公式サイトでは、ガイド類や仕様書等のコンテンツを配信しています（していく予定です）。 上の試用で、Vnanoにより深く触れてみたくなった方は、ぜひご活用ください。\n\n* [Vnano チュートリアル ガイド](https:\/\/www.vcssl.org\/ja-jp\/vnano\/doc\/tutorial\/): Vnano を実際に使用しながら、使い方や特徴などを解説する、実践形式のチュートリアル ガイドです。\n* [Vnano Engine の各種仕様](https:\/\/www.vcssl.org\/ja-jp\/vnano\/spec\/)\nVnano のスクリプトエンジンである VnanoEngine クラスのメソッド群や、オプション項目などの仕様を掲載しています。\n* [標準プラグイン](https:\/\/www.vcssl.org\/ja-jp\/vnano\/plugin\/): 各種の組み込み関数や変数を提供する、標準プラグインの一覧や各機能などの情報を掲載しています。\n* [プラグイン開発用インターフェース](https:\/\/www.vcssl.org\/ja-jp\/doc\/connect\/): プラグインを開発（自作）するための、各種インターフェースの仕様書などを掲載しています。\n* [ソースコードリポジトリ (GitHub)](https:\/\/github.com\/RINEARN\/vnano): Vnano のソースコードを管理しているリポジトリです。\n\n\n## Vnano製のコード一覧\n\n以下では、[VCSSLコードアーカイブ](https:\/\/www.vcssl.org\/ja-jp\/code\/)で配信しているコードの中から、Vnanoで記述されているものをリストアップしています。 サンプルコードや、Vnanoを搭載するソフト用のコンテンツとして、ご自由にご利用いただけます。\n\n* [FizzBuzz の答えを表示するプログラム](https:\/\/www.vcssl.org\/ja-jp\/code\/archive\/0002\/0100-vnano-fizz-buzz\/): プログラミングの練習問題としても有名な、FizzBuzz 問題の答えを表示するプログラムの例です。\n\n* [ローレンツ方程式を数値的に解くプログラム](https:\/\/www.vcssl.org\/ja-jp\/code\/archive\/0001\/8000-vnano-lorenz-attractor\/): ローレンツ方程式を4次ルンゲ=クッタ法によって解き、グラフ描画用のデータを出力するプログラムです。\n\n* [積分値を求めるプログラム (数値積分)](https:\/\/www.vcssl.org\/ja-jp\/code\/archive\/0001\/7800-vnano-integral-output\/): 矩形法\/台形法\/シンプソン法を用いて、積分の値を数値的に求めるコードです。\n\n* [積分値のグラフ描画用データを出力するプログラム](https:\/\/www.vcssl.org\/ja-jp\/code\/archive\/0001\/7900-vnano-integral-for-plot-graph\/): 数値的に積分を行い、結果の関数をグラフに描くためのデータを出力するコードです。\n\n\n---\n\n\\- 本文中の商標等について -\n\n* OracleとJavaは、Oracle Corporation 及びその子会社、関連会社の米国及びその他の国における登録商標です。文中の社名、商品名等は各社の商標または登録商標である場合があります。\n* Microsoft Windowsは、米国 Microsoft Corporation の米国およびその他の国における登録商標です。\n* Linux は、Linus Torvalds 氏の米国およびその他の国における商標または登録商標です。\n* その他、文中に使用されている商標は、その商標を保持する各社の各国における商標または登録商標です。\n\n"
	},
	"page3": {
		"title": "言語としての Vnano",
		"description": "Vnano の主な文法・仕様を、短いサンプルコードを上げながら列挙的に解説します。",
		"text": "# 言語としての Vnano\n\n## - 目次 -\n\n( &raquo; [English](LANGUAGE.md) )\n\n- [Vnano とは](#what-is)\n- [データ型](#data-type)\n- [変数宣言文](#variable)\n    - [スカラ変数の宣言](#variable-scalar)\n    - [配列の宣言](#variable-array)\n- [制御文](#control)\n    - [if 文と else 文](#control-if-else)\n    - [for 文](#control-for)\n    - [while 文](#control-while)\n    - [break 文](#control-break)\n    - [continue 文](#control-continue)\n- [式](#expression)\n    - [式の構文要素](#expression-syntax)\n    - [演算子](#expression-operator)\n- [関数](#function)\n    - [スカラを引数や戻り値とする関数](#function-scalar)\n    - [配列を引数や戻り値とする関数](#function-array)\n    - [仮引数と実引数](#function-params-and-args)\n    - [引数の値渡し](#function-call-by-value)\n    - [引数の参照渡し](#function-call-by-reference)\n- [import \/ include 宣言](#import)\n\n<hr \/>\n\n\n<a id=\"what-is\"><\/a>\n## Vnano とは\n\nVnano (VCSSL nano) は、C言語系の文法を持つ、シンプルなプログラミング言語です。\n特に、アプリケーション組み込み用途に焦点を絞った言語であるため、\n一般的なプログラミング言語と比べると、用途的に必要性の低い機能は大幅に削られています。\nこれはスクリプトエンジンの実装規模をコンパクトに抑える事で、\n機能性よりもカスタマイズ性や保守性、セキュリティ、および移植性などを優先的に高めるためです。\n\n\n<a id=\"data-type\"><\/a>\n## データ型\n\nVnano は、データ型として int (=long)、float (=double)、bool、および string 型のみをサポートしています。\n\n| 型名 | 説明 | \n| --- | --- |\n| int (or long) | 64ビット精度符号付き整数型 |\n| float (or double) | 64ビット精度浮動小数点数型 |\n| bool | 論理型 |\n| string | 文字列型 |\n\n上記以外の基本データ型や、ポインタ、構造体、およびクラスなどはサポートされません。\n一方で、上記の表にあるデータ型の配列型はサポートされており、C言語系の記法で使用できます。\n\nただし、Vnano（および VCSSL）における配列は、ポインタや参照型ではなく、値型として振舞う事に注意してください。\n配列の代入演算（=）も、参照の代入ではなく、全要素値のコピー代入になります。\n文字列についても同様で、Vnanoで文字列を扱う string 型は、参照型ではなく値型として振舞います。\n\nつまるところ、Vnano に参照型は存在せず、全てのデータ型は値型になっています。\nこれにより、Vnanoのスクリプトエンジンではガベージコレクション（GC）を省略しています。\n\nなお、配列に、要素数の異なる配列が代入される場合には、過不足なく全要素のコピーを行うために、\nコピー先（代入演算子「=」の左辺）の配列のメモリー領域が自動で再確保され、\nコピー元（右辺）と同じ要素数になるように調整されます。\n\n\n<a id=\"variable\"><\/a>\n## 変数宣言文\n\n以下のように、C言語系の表記で変数宣言文を記述できます。\n\n\n<a id=\"variable-scalar\"><\/a>\n### スカラ変数の宣言\n\n以下は、スカラ変数（配列ではない普通の変数）を宣言する例のコードです：\n\n    int    i = 1;\n    float  f = 2.3;\n    bool   b = true;\n    string s = \"Hello, World !\";\n\n    print(i, f, b, s);\n\nこのコードを[コマンドラインモード](FEATURE_JAPANESE.md#command-line-mode)で実行すると（標準プラグインが必要です）、実行結果は：\n\n    1    2.3    true    Hello, World !\n\n一方でVnanoでは、以下のように一つの文の中で複数の変数を宣言する事はできません：\n\n    (!!! このコードは動作しません !!!)\n\n    int i, j;\n    int n = 1, m = 2;\n\n\n<a id=\"variable-array\"><\/a>\n### 配列宣言\n\n配列は以下のように宣言して使用できます：\n\n    int a[8];\n    a[2] = 123;\n    print(a[2]);\n\nこのコードを [コマンドラインモード](FEATURE_JAPANESE.md#command-line-mode) で実行すると、実行結果は：\n\n    123\n\n一方でVnanoでは、以下のような配列初期化子は使用できません：\n\n    (!!! このコードは動作しません !!!)\n\n    int a[8] = { 10, 20, 30, 40, 50, 60, 70, 80 };\n\n\n<a id=\"control\"><\/a>\n## 制御文\n\nC言語系の制御文の中で、Vnano では if \/ else \/ for \/ while \/ break \/ continue 文がサポートされています。\n\n\n<a id=\"control-if-else\"><\/a>\n### if 文と else 文\n\n以下は if 文と else 文の使用例です：\n\n    int x = 1;\n    if (x == 1) {\n        print(\"x is 1.\");\n    } else {\n        print(\"x is not 1.\");\n    }\n\n実行結果は：\n\n    x is 1.\n\nところでVnanoでは、if \/ else \/ for \/ while 文の後には必ずブロック文 {...} が続かなければいけません。\n従って、以下のように if 文の後に、波括弧 { } で囲まれていない単文を記述する事はできません：\n\n    (!!! このコードは動作しません !!!)\n\n    int x = 1;\n    if (x == 1) print(\"x is 1.\");\n\n\n<a id=\"control-for\"><\/a>\n### for 文\n\n以下は for 文の使用例です：\n\n    for (int i=1; i<=5; i++) {\n        println(\"i=\" + i);\n    }\n\n\nここでも波括弧 { } は省略できない事に注意してください。実行結果は：\n\n    i=1\n    i=2\n    i=3\n    i=4\n    i=5\n\n\n<a id=\"control-while\"><\/a>\n### while 文\n\n以下は while 文の使用例です：\n\n    int a = 500;\n    while (0 <= a) {\n        println(\"a=\" + a);\n        a -= 123;\n    }\n\nここでも波括弧 { } は省略できない事に注意してください。実行結果は：\n\n    a=500\n    a=377\n    a=254\n    a=131\n    a=8\n\n\n<a id=\"control-break\"><\/a>\n### break 文\n\n以下は break 文の使用例です：\n\n    for (int i=1; i<=10; i++) {\n        println(\"i=\" + i);\n        if (i == 3) {\n            break;\n        }\n    }\n\n実行結果は：\n\n    i=1\n    i=2\n    i=3\n\n<a id=\"control-continue\"><\/a>\n### continue 文\n\n以下は continue 文の使用例です：\n\n    for (int i=1; i<=10; i++) {\n        if (i % 3 == 0) {\n            continue;\n        }\n        println(\"i=\" + i);\n    }\n\n実行結果は：\n\n    i=1\n    i=2\n    i=4\n    i=5\n    i=7\n    i=8\n    i=10\n\n\n<a id=\"expression\"><\/a>\n## 式\n\n<a id=\"expression-syntax\"><\/a>\n### 式の構文要素\n\n式は、演算処理などを記述するための、演算子とオペランドおよび括弧 ( ) で構成される一連のトークン（字句）列です。\n単独でも「;」を付ければ「式文」として文となり得ますし、加えて if 文の条件式など、他の種類の文の構成要素にもなります。\n\nここで演算子とは、要するに演算を行う記号（ + や - など）の事です。オペランドとは、演算子にとっての演算対象の事で、典型例はリテラル（1や2.3など）や識別子（変数名など）です。ただしオペランドには、さらに演算子を含む部分式が入り得ます。\n\nこのような文法的な説明だとややこしいですが、具体例としては：\n\n    (x + 2) * 3\n\nのようなものが式です。\n\n上の式において、 + と * は演算子、x と 2 と 3 はオペランド、そして ( ) は括弧です。\nただし演算子「 * 」にとっては、部分式 (x + 2) もまとめて1つのオペランドと見なせるため、\nこの呼び方は場面によっては少しあいまいです。\nそこで x と 2 と 3 のように、部分式ではない末端層のオペランドの事を、特にリーフオペランドとも呼びます。\n\nなお、VnanoではC言語と同様、代入の記号「 = 」も演算子なので、以下の内容も式になります：\n\n    y = (x + 2) * 3\n\n\n\n<a id=\"expression-operator\"><\/a>\n### 演算子\n\nVnano でサポートされている演算子は、以下の一覧の通りです。なお、優先度の値は、小さい方が高い優先度になります。\n\n| 演算子 | 優先度 | 構文 | 結合性の左右 | オペランドの型 | 演算結果の値の型 |\n| --- | --- | --- | --- | --- | --- |\n| 関数コールの ( ... , ... , ... ) | 1000 | 多項 | 左 | 関数による | 関数による |\n| 配列参照の [ ... ][ ... ][...] | 1000 | 多項 | 左 | int | 配列による |\n| ++（後置インクリメント）| 1000 | 後置 | 左 | int | int |\n| --（後置デクリメント）| 1000 | 後置 | 左 | int | int |\n| ++（前置インクリメント）| 2000 | 前置 | 右 | int | int |\n| --（前置デクリメント）| 2000 | 前置 | 右 | int | int |\n| +（単項プラス）| 2000 | 前置 | 右 | int | int |\n| -（単項マイナス） | 2000 | 前置 | 右 | int | int |\n| ! | 2000 | 前置 | 右 | bool | bool |\n| キャストの (...) | 2000 | 前置 | 右 | 任意 | 記述による |\n| * | 3000 | 二項 | 左 | int, float | int, float ※次表参照 |\n| \/ | 3000 | 二項 | 左 | int, float | int, float |\n| % | 3000 | 二項 | 左 | int, float | int, float |\n| + | 3100 | 二項 | 左 | int, float, string | int, float, string |\n| - | 3100 | 二項 | 左 | int, float | int, float |\n| < | 4000 | 二項 | 左 | int, float | bool |\n| <= | 4000 | 二項 | 左 | int, float | bool |\n| > | 4000 | 二項 | 左 | int, float | bool |\n| >= | 4000 | 二項 | 左 | int, float | bool |\n| == | 4100 | 二項 | 左 | 任意 | bool |\n| != | 4100 | 二項 | 左 | 任意 | bool |\n| && | 5000 | 二項 | 左 | bool | bool |\n| \\|\\| | 5100 | 二項 | 左 | bool | bool |\n| = | 6000 | 二項 | 右 | 任意 | 左辺の型 |\n| *= | 6000 | 二項 | 右 | int, float | int, float |\n| \/= | 6000 | 二項 | 右 | int, float | int, float |\n| %= | 6000 | 二項 | 右 | int, float | int, float |\n| += | 6000 | 二項 | 右 | int, float, string | int, float, string |\n| -= | 6000 | 二項 | 右 | int, float | int, float |\n\n\nここで二項の算術演算子（\\*, \/, %, +, -）および算術複合代入演算子（*=, \/=, %=, +=, -=）における値の型（演算された値のデータ型）は、以下の表の通りに決定されます：\n\n| オペランドAの型 | オペランドBの型 | 算術系の演算結果の値の型 |\n| --- | --- | --- |\n| int | int | int |\n| int | float | float |\n| int | string | string ( +, += のみ演算可能 ) |\n| float | int | float |\n| float | float | float |\n| float | string | string ( +, += のみ演算可能 ) |\n| string | int | string ( +, += のみ演算可能 ) |\n| string | float | string ( +, += のみ演算可能 ) |\n| string | string | string ( +, += のみ演算可能 ) |\n\n上の表において、右と左のどちらのオペランドをオペランドA（またはB）に選んでも構いません。\n\n\n<a id=\"function\"><\/a>\n## 関数\n\nVnanoのスクリプトコード内で、C言語系の記法で関数を宣言し、呼び出す事ができます。\nただし、Vnanoのスクリプトエンジンでは、ローカル変数が非常に単純な仕組みで実装されているため、\n関数の再帰呼び出しには対応していません。\n\nなお、Vnano では、プラグインによってスクリプトエンジン外部から提供される関数を「 外部関数 」と呼ぶため、\nそれに対する呼び方として、ここで扱うようにスクリプト内で宣言された関数の事を「 内部関数 」とも呼びます。\n\n<a id=\"function-scalar\"><\/a>\n### スカラを引数や戻り値とする関数\n\n以下は、スカラ変数（配列ではない普通の変数）を引数や戻り値とする関数のコード例です：\n\n    int fun(int a, int b) {\n        return a + b;\n    }\n\n    int v = fun(1, 2);\n    print(v);\n\nこのコードを [コマンドラインモード](FEATURE_JAPANESE.md#command-line-mode) で実行すると、実行結果は：\n\n    3\n\n\n<a id=\"function-array\"><\/a>\n### 配列を引数や戻り値とする関数\n\n配列を引数や戻り値にしたい場合の例は、以下の通りです：\n\n    int[] fun(int a[], int b[], int n) {\n        int c[n];\n        for (int i=0; i<n; i++) {\n            c[i] = a[i] + b[i];\n        }\n        return c;\n    }\n\n    int x[3];\n    x[0] = 0;\n    x[1] = 1;\n    x[2] = 2;\n\n    int y[3];\n    y[0] = 3;\n    y[1] = 4;\n    y[2] = 5;\n\n    int z[] = fun(x, y, 3);\n\n    println(\"z[0]=\" + z[0]);\n    println(\"z[1]=\" + z[1]);\n    println(\"z[2]=\" + z[2]);\n\nThe result is:\n\n実行結果は：\n\n    z[0]=3\n    z[1]=5\n    z[2]=7\n\n\nなお、<a href=\"#data-type\">データ型<\/a>の項目でも触れた通り、\nVnano（および VCSSL）における配列は、ポインタや参照型ではなく、値型として振舞う事に注意してください。\nこの事により、配列の引数\/戻り値の受け渡しは、デフォルトでは参照の代入ではなく、全要素値のコピー代入によって行われます\n（<a href=\"#function-call-by-value\">値渡し<\/a> と \n  <a href=\"#function-call-by-reference\">参照渡し<\/a> の項目も参照）。\nその際、要素数の異なる配列がコピーされる場合には、過不足なく全要素のコピーを行うために、コピー先（受け取り側）\nの配列のメモリー領域が自動で再確保され、コピー元と同じ要素数になるように調整されます。\n従って上記のコードでは、いくつかの場所で、配列宣言時に要素数を指定するのを省略しています（ \"int a[]\"、 \"int b[]\"、 および \"int z[] = fun(x, y, 3)\" の箇所 ）。\n\n\n<a id=\"function-params-and-args\"><\/a>\n### 仮引数と実引数\n\n以下の例の「 a 」のように、関数側で宣言されている引数の事を「仮引数」と呼びます。それに対して、以下の例の「 x 」のように、呼び出し元から関数に渡している引数の事を「実引数」と呼びます。\n\n    void fun(int a) {\n        ...\n    }\n\n    ...\n\n    fun(x);\n\n\n<a id=\"function-call-by-value\"><\/a>\n### 引数の値渡し\n\nデフォルトでは、関数内における仮引数の値の変更は、呼び出し元の実引数の値には反映されません。例えば：\n\n    void fun(int a, int b[]) {\n        a = 2;\n        b[0] = 10;\n        b[1] = 11;\n        b[2] = 12;\n    }\n\n    int x = 0;\n    int y[3];\n    y[0] = 0;\n    y[1] = 0;\n    y[2] = 0;\n\n    fun(x, y);\n\n    println(\"x = \" + x);\n    println(\"y[0] = \" + y[0]);\n    println(\"y[1] = \" + y[1]);\n    println(\"y[2] = \" + y[2]);\n\n実行結果は：\n\n    x = 0\n    y[0] = 0\n    y[1] = 0\n    y[2] = 0\n\n上の例の通り、関数「 fun 」内で仮引数「 a 」と「 b 」の値を変更していますが、 呼び出し元の実引数「 x 」と「 y 」の値は変化していない事がわかります。\n\nこれは、デフォルトでの関数の引数の受け渡しが、単純に「 実引数の値を仮引数にコピーする 」事によって行われるからです。\nこのような引数の渡し方を「値渡し」と呼びます。\n\n\n<a id=\"function-call-by-reference\"><\/a>\n### 引数の参照渡し\n\n関数内での仮引数の値の変更を、呼び出し元の実引数の値に反映させたい場合は、仮引数の宣言において、名前の前に「 & 」記号を付加してください。例えば：\n\n    void fun(int &a, int &b[]) {\n        a = 2;\n        b[0] = 10;\n        b[1] = 11;\n        b[2] = 12;\n    }\n\n    int x = 0;\n    int y[3];\n    y[0] = 0;\n    y[1] = 0;\n    y[2] = 0;\n\n    fun(x, y);\n\n    println(\"x = \" + x);\n    println(\"y[0] = \" + y[0]);\n    println(\"y[1] = \" + y[1]);\n    println(\"y[2] = \" + y[2]);\n\n実行結果は：\n\n    x = 2\n    y[0] = 10\n    y[1] = 11\n    y[2] = 12\n\n上の例の通り、関数「 fun 」内で仮引数「 a 」と「 b 」の値を変更した結果、呼び出し元の実引数「 x 」と「 y 」も、同じ値に変化した事がわかります。これは、「 & 」を付けて宣言された仮引数のデータへのメモリ参照が、実引数のデータへのメモリ参照と共有されるためです。このような引数の渡し方を「参照渡し」と呼びます。\n\n\n<a id=\"import\"><\/a>\n## import \/ include 宣言\n\nVnano の親言語（フルセット版）である VCSSL では、スクリプト内で import 宣言や include 宣言を記述する事により、ライブラリを読み込む事ができます。例えば：\n\n    import ExampleLibrary;\n\n    float value = exampleFunction(1.2);\n\nなどと記述すると、import 宣言の箇所で ExampleLibrary ライブラリが自動で読み込まれ、それに属する exampleFunction 関数がコード内で使えるようになる、といった具合です。\n\n一方で、アプリケーション組み込み用に機能が絞られた Vnano では、スクリプト側からのライブラリの読み込み指示や、プラグインの接続指示などはできません。使用する全てのライブラリやプラグインは、アプリケーション側や設定ファイル等で導入\/指定しておく必要があります（[Vnano Engine の主な機能と用例](FEATURE_JAPANESE.md) 参照）。これは、組み込み用途でのセキュリティ等を考慮した仕様です。\n\nしかしながら、import \/ include 宣言自体は、Vnano のスクリプト内でも記述できます。\nVnano では、import \/ include 宣言があると、「 指定されているライブラリ（または同名の名前空間を提供するプラグイン）が読み込み済みかどうか 」を確認し、無ければその旨のエラーメッセージを表示してくれます。\n\n例えば、上のサンプルコードを Vnano スクリプトとして実行すると、ExampleLibrary という名前のライブラリ（または「 ExampleLibrary 」名前空間を提供するプラグイン）が未読み込みなら：\n\n    このスクリプトは「 ExampleLibrary 」の機能群を使用しますが、それを提供するライブラリ\/プラグインが読み込まれていません。\n    ライブラリ\/プラグインの読み込み設定を確認してください。\n\nというエラーが表示されます。もし「 import ExampleLibrary; 」の行が無ければ：\n\n    存在しない関数「 exampleFunction(float) 」を呼び出しています。\n\nというエラーが表示されます。前者のエラーメッセージの方が、より根本的な原因を伝えていて、どうすればいいかも分かりやすい内容です。\n\nimport \/ include 宣言で指定したライブラリやプラグインが、読み込み済みで利用可能な場合には、何も起こりません。\n従って、Vnano では書いても書かなくても構わないのですが、書いておくと、一応は上記のような利点があります。\n\n"
	}
}
