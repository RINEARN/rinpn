{
	"page0": {
		"title": "Vnano Official Website",
		"description": "The frontpage of the official website, introduing features of Vnano.",
		"text": "# Vnano Official Website\n\nWelcome to the official website of the scripting engine\/language \"Vnano\".\n\n\n## What is the Vnano ?\n\n### A Compact Scripting Engine\/Language, Embeddable in Java&trade; Applications\n\nVnano (VCSSL nano) is a compact and high-speed scripting engine\/language that can be embedded in Java applications. This allows you to easily implement scripting features in your apps.\n\n&raquo; [An Example of an Application Using Vnano: RINPn (Scientific Calculator)](https:\/\/www.rinearn.com\/en-us\/rinpn\/)\n\n### Also Available for Standalone Use, Similar to Other Scripting Languages\n\nYou can also execute Vnano scripts on your PC by installing the [VCSSL Runtime](https:\/\/www.vcssl.org\/en-us\/download\/).\nAlthough Vnano's features are streamlined to prioritize embeddability, its operational speed is very high, making it particularly useful for calculation-intensive tasks.\n\n&raquo; [Example: A Script Calculating Integral Values](https:\/\/www.vcssl.org\/en-us\/code\/archive\/0001\/7800-vnano-integral-output\/)\n\n### Simple C-like Syntax\n\nVnano features a simple C-like syntax, making it easy for programmers accustomed to C or similar languages to write and read Vnano scripts.\n\n\\- Example of a script written in Vnano -\n\n    int sum = 0;\n    for (int i=1; i<=100; i++) {\n        sum += i;\n    }\n    output(sum);\n\n&raquo; [More Details: Features of Vnano as a Language](https:\/\/www.vcssl.org\/en-us\/vnano\/doc\/tutorial\/language)\n\n### Open Source, MIT License\n\nThe Vnano scripting engine is open-source software and is released under the MIT License.\n\n&raquo; [Source Code Repository](https:\/\/github.com\/RINEARN\/vnano)\n\n\n## How to Use\n\nYou can start using Vnano in just a few minutes. Let's get started!\n\n### Step1. Download the Vnano Engine\n\nFirst, download the pre-built Vnano package by clicking the following button, and extract the ZIP file. Within the extracted folder, you will find the JAR file \"Vnano.jar,\" which is the scripting engine of Vnano (Vnano Engine).\n\n[Vnano Official Website, Download button of the pre-built package](https:\/\/www.vcssl.org\/en-us\/vnano\/)\n\n    * Please accept the license agreement (MIT License) before use. &raquo; [License](https:\/\/github.com\/RINEARN\/vnano\/blob\/master\/LICENSE)\n\n    * This pre-built package is for trial purposes and may not function correctly depending on the JDK\/JRE version in your environment. For more reliable usage, build the JAR file from the source code using the same JDK as your development environment. &raquo; [How to Build](https:\/\/www.vcssl.org\/ja-jp\/vnano\/doc\/tutorial\/use)\n\nAlso, if you simply want to execute Vnano scripts, similar to other scripting languages, without embedding the engine in any applications, consider installing the [VCSSL Runtime](https:\/\/www.vcssl.org\/en-us\/download\/) instead.\n\n\n### Step2. Run the Example Script\n\nWithin the extracted folder, you'll find an example script file named \"ExampleScript1.vnano\" written in Vnano:\n\n\\- ExampleScript1.vnano -\n\n    int sum = 0;\n    for (int i=1; i<=100; i++) {\n        sum += i;\n    }\n    output(sum);\n\nThis script calculates the sum of integers from 1 to 100. To run it, navigate to the extracted folder in your command-line terminal and enter the following command:\n\n    java -jar Vnano.jar ExampleScript1.vnano\n\n    # Note: Running this script requires the Java Development Kit: JDK.\n\nAdditionally, if the [VCSSL Runtime](https:\/\/www.vcssl.org\/en-us\/download\/) is installed on your PC, you can execute this script easily by launching the runtime and selecting the script. You can also run it via the command line if you have configured the path settings.\n\nThe output will display the calculated value:\n\n    5050\n\n\n### Step3. Example Java Application\n\nWithin the extracted folder, you'll find an example of a Java application that uses the Vnano, named \"ExampleApp1.java\":\n\n\\- ApplicationExample.java -\n\n    import org.vcssl.nano.VnanoEngine;\n    import org.vcssl.nano.VnanoException;\n\n    public class ExampleApp1 {\n        public static void main(String[] args) throws VnanoException {\n\n            \/\/ Vnano のスクリプト実行エンジン（Vnano Engine）のインスタンスを生成\n            VnanoEngine engine = new VnanoEngine();\n\n            \/\/ 単純な内容のスクリプトを用意し、Vnano Engine で実行\n            String script = \"double a = 1.2;  double b = 3.4;  double c = a + b;  c;\";\n            double result = (Double)engine.executeScript(script);\n\n            \/\/ 結果を表示\n            System.out.println(\"result: \" + result);\n        }\n    }\n\nThis application executes a Vnano script that calculates the sum of \"1.2 + 3.4\".\n\nTo compile and run this application, navigate to the extracted folder and use the following commands:\n\n    # For Windows\n    javac -cp .;Vnano.jar ExampleApp1.java\n    java -cp \".;Vnano.jar\" ExampleApp1\n\n    # For other operating systems\n    javac -cp .:Vnano.jar ExampleApp1.java\n    java -cp \".:Vnano.jar\" ExampleApp1\n\n    # Note: Running this requires the Java Development Kit: JDK.\n\nThe output should display:\n\n    result: 4.6\n\nThis confirms the successful computation of \"1.2 + 3.4\" using the scripting engine.\n\nFor a more detailed explanation of how to use Vnano, refer to the following page:\n\n&raquo; More Drtails: [How to Use Vnano](https:\/\/www.vcssl.org\/ja-jp\/vnano\/doc\/tutorial\/)\n\n\n## Contents of This Website\n\n* [Vnano Tutorial Guide](https:\/\/www.vcssl.org\/en-us\/vnano\/doc\/tutorial\/): A simple tutorial guide for using Vnano.\n* [Specifications of Vnano Engine](https:\/\/www.vcssl.org\/en-us\/vnano\/spec\/): Documentation on the VnanoEngine class, options, and other technical details.\n* [Standard Plug-ins](https:\/\/www.vcssl.org\/en-us\/vnano\/plugin\/): A list and detailed specifications of standard plug-ins that provide built-in functions and variables.\n* [Plug-ins Interface](https:\/\/www.vcssl.org\/ja-jp\/doc\/connect\/): \nThe interface for Plug-in development.\n* [Source Code Repository (GitHub)](https:\/\/github.com\/RINEARN\/vnano): The remote repository where the source code of Vnano is managed.\n\n\n## Code Written in Vnano\n\nVarious official Vnano code samples are available in the [VCSSL Code Archive](https:\/\/www.vcssl.org\/en-us\/code\/). These may serve as useful examples for understanding Vnano.\n\n* [Fizz Buzz Program](https:\/\/www.vcssl.org\/en-us\/code\/archive\/0002\/0100-vnano-fizz-buzz\/): A program printing the correct result of Fizz Buzz game.\n\n* [Solve The Lorenz Equations Numerically](https:\/\/www.vcssl.org\/en-us\/code\/archive\/0001\/8000-vnano-lorenz-attractor\/): Solve the Lorenz equations, and output data to plot the solution curve (well-known as the \"Lorenz Attractor\") on a 3D graph.\n\n* [Compute Integral Value Numerically](https:\/\/www.vcssl.org\/en-us\/code\/archive\/0001\/7800-vnano-integral-output\/): Example code computing integral values numerically by using rectangular method, trapezoidal method, and Simpson's rule.\n\n* [Output Data of Numerical Integration For Plotting Graph](https:\/\/www.vcssl.org\/en-us\/code\/archive\/0001\/7900-vnano-integral-for-plot-graph\/): Example code computing integrated values numerically, and output data for plotting the integrated functions into graphs.\n\n\n---\n\n\\- Credits and Trademarks -\n\n* Oracle and Java are registered trademarks of Oracle and\/or its affiliates.\n* Microsoft Windows is either a registered trademarks or trademarks of Microsoft Corporation in the United States and\/or other countries.\n* Linux is a trademark of linus torvalds in the United States and\/or other countries.\n* Other names may be either a registered trademarks or trademarks of their respective owners.\n\n"
	},
	"page3": {
		"title": "Vnano as a Language",
		"description": "Explaining syntax and language features of Vnano.",
		"text": "# The Vnano as a Language\n\n## - Index -\n\n( &raquo; [Japanese](LANGUAGE_JAPANESE.md) )\n\n- [What is Vnano?](#what-is)\n- [Data Types](#data-type)\n- [Variable Declaration Statements](#variable)\n    - [Daclaration of scalar variables](#variable-scalar)\n    - [Daclaration of arrays](#variable-array)\n- [Control Statements](#control)\n    - [if and else statements](#control-if-else)\n    - [for statement](#control-for)\n    - [while statement](#control-while)\n    - [break statement](#control-break)\n    - [continue statement](#control-continue)\n- [Expressions](#expression)\n    - [Syntax elements of expressions](#expression-syntax)\n    - [Operators](#expression-operator)\n- [Functions](#function)\n    - [Scalar input\/output functions](#function-scalar)\n    - [Array input\/output functions](#function-array)\n    - [Formal parameters and actual arguments](#function-params-and-args)\n    - [Call by value](#function-call-by-value)\n    - [Call by reference](#function-call-by-reference)\n- [\"import\" and \"include\" Declarations](#import)\n\n<hr \/>\n\n\n<a id=\"what-is\"><\/a>\n## What is Vnano?\n\nThe Vnano (VCSSL nano) is a programming language having simple C-like syntax.\nLanguage specifications of the Vnano is specialized for embedded use in applications, \nso compared with other programming languages, many features not necessary for the embedded use are omitted \nfor making the implementation of the script engine compact.\nIt is the concept for giving priority to customizability, maintainability, security, portability \nand so on than the functionality.\n\n\n<a id=\"data-type\"><\/a>\n## Data Types\n\nVnano supports only int (=long), float (=double), bool, and string for data-types.\n\n| Type name | Description | \n| --- | --- |\n| int (or long) | The 64-bit signed integer type |\n| float (or double) | The 64-bit floating point number type |\n| bool | The boolean type |\n| string | The character string type |\n\nOther primitive data types, pointer, struct and class are not supported.\nOn the other hand, array types of the data types in the above table are supported, \nand you can use it with C-like syntax.\n\nHowever, please note that arrays in the Vnano (and VCSSL) behaves as value types, not reference types or pointers.\nThe assignment operation (=) of an array behaves as the copy of all values of elements, not the copy of the reference to (address on) the memory.\nIt is the same for character strings. \nIn the Vnano, the \"string\" type which is the data type to store character strings behaves as the value type, not reference type.\n\nIn short, Vnano has no reference types, so all data types in the Vnano are value types.\nBecause of that, the script engine of the Vnano has no garbage-collection (GC) modules.\n\nBy the way, if sizes of arrays at the left-hand and the right-hand of the assignment operation (=) are different, \nthe size of the left-hand array will be adjusted to the same size with the right-hand array, \nby re-allocating memory of the left-hand array automatically.\n\n\n<a id=\"variable\"><\/a>\n## Variable Declaration Statements\n\nYou can describe the variable declaration statements with C-like syntax.\n\n\n<a id=\"variable-scalar\"><\/a>\n### Declaration of scalar variables\n\nThe following is an example code of declaration statements of scalar variables (non-array variables) :\n\n    int    i = 1;\n    float  f = 2.3;\n    bool   b = true;\n    string s = \"Hello, World !\";\n\n    print(i, f, b, s);\n\nThe result on [the command-line mode](FEATURE.md#command-line-mode) (standard plug-ins are required) is: \n\n    1    2.3    true    Hello, World !\n\nHowever, you can NOT declare multiple variable in 1 statement in the Vnano:\n\n    (!!! This code does not work !!!)\n\n    int i, j;\n    int n = 1, m = 2;\n\n\n<a id=\"variable-array\"><\/a>\n### Declaration of arrays\n\nYou can declare and use arrays as follows:\n\n    int a[8];\n    a[2] = 123;\n    print(a[2]);\n\nThe result on [the command-line mode](FEATURE.md#command-line-mode) is: \n\n    123\n\nHowever, you can NOT use array initializers in the Vnano:\n\n    (!!! This code does not work !!!)\n\n    int a[8] = { 10, 20, 30, 40, 50, 60, 70, 80 };\n\n\n<a id=\"control\"><\/a>\n## Control Statements\n\nIn control statements of C-like languages, Vnano supports \"if\" \/ \"else\" \/ \"for\" \/ \"while\" \/ \"continue\" \/ \"break\" statements.\n\n<a id=\"control-if-else\"><\/a>\n### \"if\" and \"else\" statements\n\nThe folloing is an example code of \"if\" and \"else\" statements:\n\n    int x = 1;\n    if (x == 1) {\n        print(\"x is 1.\");\n    } else {\n        print(\"x is not 1.\");\n    }\n\nThe result is:\n\n    x is 1.\n\nBy the way, in the Vnano, after of \"if\" \/ \"else\" \/ \"for\" \/ \"while\" statements must be a block statement {...}.\nSo you can NOT write single statement which is not enclosed by braces { } after the \"if\" statement as follows:\n\n    (!!! This code does not work !!!)\n\n    int x = 1;\n    if (x == 1) print(\"x is 1.\");\n\nHowever, for \"else\" statement at just before of \"if\" statement (so-called \"else if\"), braces { } can be omitted.\n\n<a id=\"control-for\"><\/a>\n### \"for\" statement\n\nThe folloing is an example code of \"for\" statement:\n\n    for (int i=1; i<=5; i++) {\n        println(\"i=\" + i);\n    }\n\n\nPlease note that braces { } can not be omitted. The result is:\n\n    i=1\n    i=2\n    i=3\n    i=4\n    i=5\n\n\n<a id=\"control-while\"><\/a>\n### \"while\" statement\n\nThe folloing is an example code of \"while\" statement:\n\n    int a = 500;\n    while (0 <= a) {\n        println(\"a=\" + a);\n        a -= 123;\n    }\n\nPlease note that braces { } can not be omitted. The result is:\n\n    a=500\n    a=377\n    a=254\n    a=131\n    a=8\n\n\n<a id=\"control-break\"><\/a>\n### \"break\" statement\n\nThe folloing is an example code of \"break\" statement:\n\n    for (int i=1; i<=10; i++) {\n        println(\"i=\" + i);\n        if (i == 3) {\n            break;\n        }\n    }\n\nThe result is:\n\n    i=1\n    i=2\n    i=3\n\n<a id=\"control-continue\"><\/a>\n### \"continue\" statement\n\nThe folloing is an example code of continue statement:\n\n    for (int i=1; i<=10; i++) {\n        if (i % 3 == 0) {\n            continue;\n        }\n        println(\"i=\" + i);\n    }\n\nThe result is:\n\n    i=1\n    i=2\n    i=4\n    i=5\n    i=7\n    i=8\n    i=10\n\n\n<a id=\"expression\"><\/a>\n## Expressions\n\n<a id=\"expression-syntax\"><\/a>\n### Syntax elements of expressions\n\nAn expression is a series of tokens to describe operations, consists of operators, operands, and parentheses ( ).\nAn expression can be a statement as an \"expression statement\" by itself (when it ends with \";\").\nIn addition, expressions can be parts of other kinds of statements, e.g.: a condition expression of \"if\" statement.\n\nAs syntactic elements of expressions, \"operators\" are symbols of operations, e.g.: \"+\", \"-\", and so on.\nValues to be operated are called as \"operands\", e.g.: 1 and 2.3 for \"1 + 2.3\". \nMore specifically, as syntactic elements, values directly described such as \"1\", \"2.3\" and so on are called as \"literals\".\nBesides literals, identifiers of variables (e.g.: \"x\"), and results of other operations can be operands.\n\nThe syntactic definition of expressions like above is complicated and difficult, so Let's see a typical example:\n\n    (x + 2) * 3\n\nThe above is an expression.\nIn this expression, \"+\" and \"*\" are operators, \"x\" and \"2\" and \"3\" are operands, \n\"(\" and \")\" are parentheses.\n\nHowever, the result of the addition \"(x + 2)\" is also an operand for the \"*\" operator, \nso the word \"operands\" is ambiguous. \nFor disambiguation, sometimes minimum units of operands such as \"x\" and \"2\" and \"3\" are syntactically called as \"leaf operands\".\n\nBy the way, in the Vnano, as the same with the C programming language, \nthe symbol of the assignment \"=\" is an operator, so the following is also an expression:\n\n    y = (x + 2) * 3\n\n\n\n<a id=\"expression-operator\"><\/a>\n### Operators\n\nThe following is the list of operators supported in the Vnano.\nNote that, smaller \"precedence\" value gives higher precedence.\n\n| Operator | Precedence | Syntax | Associativity | Type of Operands | Type of Operated Value |\n| --- | --- | --- | --- | --- | --- |\n| ( ... , ... , ... ) as call | 1000 | multiary | left | any | any |\n| [ ... ][ ... ][...] as index | 1000 | multiary | left | int | any |\n| ++ (post-increment) | 1000 | postfix | left | int | int |\n| -- (post-decrement) | 1000 | postfix | left | int | int |\n| ++ (pre-increment) | 2000 | prefix | right | int | int |\n| -- (pre-decrement) | 2000 | prefix | right | int | int |\n| + (unary-plus) | 2000 | prefix | right | int | int |\n| - (unary-minus) | 2000 | prefix | right | int | int |\n| ! | 2000 | prefix | right | bool | bool |\n| (...) as cast | 2000 | prefix | right | any | any |\n| * | 3000 | binary | left | int, float | int, float (See the next table) |\n| \/ | 3000 | binary | left | int, float | int, float |\n| % | 3000 | binary | left | int, float | int, float |\n| + | 3100 | binary | left | int, float, string | int, float, string |\n| - | 3100 | binary | left | int, float | int, float |\n| < | 4000 | binary | left | int, float | bool |\n| <= | 4000 | binary | left | int, float | bool |\n| > | 4000 | binary | left | int, float | bool |\n| >= | 4000 | binary | left | int, float | bool |\n| == | 4100 | binary | left | any | bool |\n| != | 4100 | binary | left | any | bool |\n| && | 5000 | binary | left | bool | bool |\n| \\|\\| | 5100 | binary | left | bool | bool |\n| = | 6000 | binary | right | any | any |\n| *= | 6000 | binary | right | int, float | int, float |\n| \/= | 6000 | binary | right | int, float | int, float |\n| %= | 6000 | binary | right | int, float | int, float |\n| += | 6000 | binary | right | int, float, string | int, float, string |\n| -= | 6000 | binary | right | int, float | int, float |\n\n\nThe value type (the data-type of the operated value) of binary arithmetic operators (\\*, \/, %, +, -) \nand compound arithmetic assignment operators (*=, \/=, %=, +=, -=) are decided by the following table:\n\n| Type of Operand A | Type of Operand B | Type of Operated Value |\n| --- | --- | --- |\n| int | int | int |\n| int | float | float |\n| int | string | string |\n| float | int | float |\n| float | float | float |\n| float | string | string |\n| string | int | string |\n| string | float | string |\n| string | string | string |\n\nWhere you can choose the right or the left operand as the operand A (or operand B) freely in the above table.\n\n\n<a id=\"function\"><\/a>\n## Functions\n\nYou can declare and call functions in the Vnano script code with C-like syntax. \n\nNote that, the Vnano does not support recursive calls of functions, \nbecause allocations of local variables are implemented in very simple way in the script engine of the Vnano.\n\nAlso, in the Vnano, functions declared in scripts are called as \"internal functions\", \nin contrast to that, functions provided by plug-ins connectet to the script engine are called as \"external functions\".\n\n\n<a id=\"function-scalar\"><\/a>\n### Scalar input\/output functions\n\n\nThe following is an example code of the function of which arguments and the return value is scalar (non-array) values:\n\n    int fun(int a, int b) {\n        return a + b;\n    }\n\n    int v = fun(1, 2);\n    print(v);\n\nThe result on [the command-line mode](FEATURE.md#command-line-mode) is: \n\n    3\n\n\n<a id=\"function-array\"><\/a>\n### Array input\/output functions\n\nIf you want to return an array, or get arrays as arguments, the following code is an example:\n\n    int[] fun(int a[], int b[], int n) {\n        int c[n];\n        for (int i=0; i<n; i++) {\n            c[i] = a[i] + b[i];\n        }\n        return c;\n    }\n\n    int x[3];\n    x[0] = 0;\n    x[1] = 1;\n    x[2] = 2;\n\n    int y[3];\n    y[0] = 3;\n    y[1] = 4;\n    y[2] = 5;\n\n    int z[] = fun(x, y, 3);\n\n    println(\"z[0]=\" + z[0]);\n    println(\"z[1]=\" + z[1]);\n    println(\"z[2]=\" + z[2]);\n\nThe result is:\n\n\n    z[0]=3\n    z[1]=5\n    z[2]=7\n\n\nPlease note that, as we mentioned in the section of <a href=\"#data-type\">Data Types<\/a>, \narrays in the Vnano (and VCSSL) behaves as value types, not reference types or pointers.\nBy default, assignment operations of arguments and the return value behaves as the copy of all values of elements, not the copy of the reference to (address on) the memory \n(See also: <a href=\"#function-call-by-value\">Call by value<\/a> and  \n <a href=\"#function-call-by-reference\">Call by reference<\/a>).\nIn addition, the size of the array will be adjusted automatically when an array having different size will copied to it, \nso we omitted to specify size of array declarations in several places in the above code, e.g.: \"int a[]\", \"int b[]\", and \"int z[] = fun(x, y, 3)\".\n\n\n<a id=\"function-params-and-args\"><\/a>\n### Formal parameters and actual arguments\n\nThe parameter-variable declared in a function declaration like as \"a\" in the following example is called as \"formal parameter\". In contrast, the value\/variable passed to a function like as \"x\" in the following example is called as \"actual argument\".\n\n    void fun(int a) {\n        ...\n    }\n\n    ...\n\n    fun(x);\n\n\n<a id=\"function-call-by-value\"><\/a>\n### Call by value\n\nBy default, change of values of formal parameters in functions don't affect to values of actual arguments of caller-side, For example:\n\n    void fun(int a, int b[]) {\n        a = 2;\n        b[0] = 10;\n        b[1] = 11;\n        b[2] = 12;\n    }\n\n    int x = 0;\n    int y[3];\n    y[0] = 0;\n    y[1] = 0;\n    y[2] = 0;\n\n    fun(x, y);\n\n    println(\"x = \" + x);\n    println(\"y[0] = \" + y[0]);\n    println(\"y[1] = \" + y[1]);\n    println(\"y[2] = \" + y[2]);\n\nThe result is:\n\n    x = 0\n    y[0] = 0\n    y[1] = 0\n    y[2] = 0\n\nAs demonstrated by the above result, actual arguments of caller-side \"x\" and \"y\" have not changed although formal parameters \"a\" and \"b\" changed in the function \"fun\". This is because, by default, actual arguments will be simply copied once to formal parameters when the function is called. This behaviour is called as \"call-by-value\".\n\n\n<a id=\"function-call-by-reference\"><\/a>\n### Call by reference\n\nIf you want to affect changed values of formal parameters in functions to values of actual arguments of caller-side, describe the symbol \"&\" before the name of formal parameters in declarations of them. For example:\n\n    void fun(int &a, int &b[]) {\n        a = 2;\n        b[0] = 10;\n        b[1] = 11;\n        b[2] = 12;\n    }\n\n    int x = 0;\n    int y[3];\n    y[0] = 0;\n    y[1] = 0;\n    y[2] = 0;\n\n    fun(x, y);\n\n    println(\"x = \" + x);\n    println(\"y[0] = \" + y[0]);\n    println(\"y[1] = \" + y[1]);\n    println(\"y[2] = \" + y[2]);\n\nThe result is:\n\n    x = 2\n    y[0] = 10\n    y[1] = 11\n    y[2] = 12\n\nThe memory-reference to data of a formal parameter declared with \"&\" will be shared with reference to data of an actual argument. Hence, as demonstrated by the above result, after values of formal parameters \"a\" and \"b\" in the function \"fun\" changed, actual arguments \"x\" and \"y\" of caller-side also changed to same values with \"a\" and \"b\". This behaviour is called as \"call-by-reference\".\n\n\n\n<a id=\"import\"><\/a>\n## \"import\" and \"include\" Declarations\n\nIn the VCSSL, which is the \"parent language\" of the Vnano, \nwe can describe \"import\" \/ \"include\" declarations in scripts, for loading specified libraries.\nFor example:\n\n    import ExampleLibrary;\n\n    float value = exampleFunction(1.2);\n\nIf we execute the above code as a VCSSL script, \nthe \"ExampleLibrary\" will be loaded automatically by the line \"import ExampleLibrary;\", and then its member function \"exampleFunction\" will be available in the script.\n\nOn the other hand, in the Vnano (is a subset of the VCSSL for embedded use), scripts can not request the scripting engine to load libraries\/plug-ins.\nAll libraries\/plug-ins must be loaded\/specified by application-side code or setting files (see [Main Features of Vnano Engine, and Examples](FEATURE.md)), not scripts.\nThis is a restriction for keeping security in embedded use.\n\nHowever, it is possible to \"import\" or \"include\" declarations in Vnano scripts, though the specified libraries\/plug-ins will not load automatically.\nIf an \"import\" \/ \"include\" declaration exists in a Vnano script, the scripting engine confirms that \nwhether the specified library (or the plug-in providing the same namespace) has been loaded.\nIf it has not been loaded, the engine notify the user of missing the library\/plug-in, as an error message.\n\nFor example, if we execute the above example code as a Vnano script, and the library \"ExampleLibrary\" (or the plug-in prividing \"ExampleLibrary\" namespace) is not loaded, the following error message will be displayed:\n\n    This script requires features of \"ExampleLibrary\", but no library or plug-in providing them is not loaded.\n    Check the settings to load libraries\/plug-ins.\n\nAlso, if we removed the line \"import ExampleLibrary;\" from the script, the error message changes to the following: \n\n    Unknown function \"exampleFunction(float)\" is called.\n\nThe former error message is more user friendly than the latter one, because the user can grasp what they should do for solving the problem.\n\nWhen the specified librarie or plug-in has been loaded and is available, nothing occurs by the \"import\" \/ \"include\" declaration.\nHence, \"import\" \/ \"include\" declarations are not mandatory for Vnano scripts, but they give the advantage shown in the above.\n\n"
	}
}
